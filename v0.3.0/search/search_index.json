{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Noisy Simulation","text":"<p>Running programs on NISQ devices often leads to imperfect results due to the presence of noise. In order to perform realistic simulations, a number of noise models (for digital operations, analog operations and simulated readout errors) are supported in <code>Qadence</code>.</p> <p>Noisy simulations shift the quantum paradigm from a close-system (noiseless case) to an open-system (noisy case) where a quantum system is represented by a probabilistic combination \\(p_i\\) of possible pure states \\(|\\psi_i \\rangle\\). Thus, the system is described by a density matrix \\(\\rho\\) (and computation modify the density matrix) defined as follows:</p> \\[ \\rho = \\sum_i p_i |\\psi_i\\rangle \\langle \\psi_i| \\] <p>The noise protocols applicable in <code>Qermod</code> are classified into three types: digital (for digital operations), analog (for analog operations), and readout error (for measurements).</p>"},{"location":"#available-noise-models","title":"Available noise models","text":""},{"location":"#digital-noisy-simulation","title":"Digital noisy simulation","text":"<p>Digital noise refer to unintended changes occurring with reference to the application of a noiseless digital gate operation. Several noise models are made available via the<code>PyQTorch</code> backend. Given an <code>error_definition</code> user-defined input, we support the following digital noise models:</p> <ul> <li><code>Bitflip</code>: flips between |0\u27e9 and |1\u27e9 with <code>error_definition</code></li> <li><code>Phaseflip</code>: flips the phase of a qubit by applying a Z gate with <code>error_definition</code></li> <li><code>DigitalDepolarizing</code>: randomizes the state of a qubit by applying I, X, Y, or Z gates with equal <code>error_definition</code></li> <li><code>PauliChannel</code>: applies the Pauli operators (X, Y, Z) to a qubit with specified probabilities (via <code>error_definition</code>)</li> <li><code>AmplitudeDamping</code>: models the asymmetric process through which the qubit state |1\u27e9 irreversibly decays into the state |0\u27e9 with <code>error_definition</code></li> <li><code>PhaseDamping</code>: similar to AMPLITUDE_DAMPING but concerning the phase</li> <li><code>GeneralizedAmplitudeDamping</code>: extends amplitude damping; the first float is <code>error_definition</code> of amplitude damping, and second float is the <code>damping_rate</code>.</li> </ul>"},{"location":"#readout-errors","title":"Readout errors","text":"<p>Readout errors are linked to the incorrect measurement outcomes from the system. They are typically described using confusion matrices of the form:</p> \\[ T(x|x')=\\delta_{xx'} \\] <p>Two types of readout protocols are available:</p> <ul> <li><code>Independent</code> where each bit can be corrupted independently of each other.</li> <li><code>Correlated</code> where we can define of confusion matrix of corruption between each possible bitstrings.</li> </ul>"},{"location":"#analog-noisy-simulation","title":"Analog noisy simulation","text":"<p>Analog noise can be set for analog operations. At the moment, analog noisy simulations are only compatible with the <code>Pulser</code> backend, and we support the following models:</p> <ul> <li><code>AnalogDepolarizing</code>: evolves to the maximally mixed state with probabilities defined with <code>error_definition</code></li> <li><code>Dephasing</code>: induces the loss of phase coherence without affecting the population of computational basis states</li> </ul>"},{"location":"#implementation","title":"Implementation","text":"<p>Several predefined noise models are available in <code>Qermod</code>.</p> <pre><code>from qermod import AnalogDepolarizing, Bitflip, IndependentReadout\n\nanalog_noise = AnalogDepolarizing(error_definition=0.1)\ndigital_noise = Bitflip(error_definition=0.1)\nreadout_noise = IndependentReadout(error_definition=0.1)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"#chaining","title":"Chaining","text":"<p>One can also compose noise configurations via the <code>chain</code> method, or by using the <code>|</code> or <code>|=</code> operator.</p> <pre><code>from qermod import chain\n\ndigital_readout = digital_noise | readout_noise\nprint(digital_readout)\n\ndigital_readout = chain(digital_noise, readout_noise)\nprint(digital_readout)\n</code></pre> <pre><code>blocks=(Bitflip(protocol=&lt;DigitalNoiseType.BITFLIP: 'BitFlip'&gt;, error_definition=0.100000000000000, target=[]), IndependentReadout(protocol=&lt;ReadoutNoise.INDEPENDENT: 'Independent Readout'&gt;, error_definition=0.100000000000000, target=[], seed=None, noise_distribution=None))\nblocks=(Bitflip(protocol=&lt;DigitalNoiseType.BITFLIP: 'BitFlip'&gt;, error_definition=0.100000000000000, target=[]), IndependentReadout(protocol=&lt;ReadoutNoise.INDEPENDENT: 'Independent Readout'&gt;, error_definition=0.100000000000000, target=[], seed=None, noise_distribution=None))\n</code></pre> <p>Noise scope</p> <p>Note it is not possible to define a noise configuration with both digital and analog noises, both readout and analog noises, several analog noises, several readout noises, or a readout noise that is not the last defined protocol in a sequence.</p>"},{"location":"#parametric-noise","title":"Parametric noise","text":"<p>Noise definition can be made parametric via <code>qadence.parameters.Parameter</code>:</p> <pre><code>from qadence.parameters import Parameter\ndigital_noise = Bitflip(error_definition=Parameter('p', trainable=True))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"#serialization","title":"Serialization","text":"<p>Serialization is enabled via the <code>qermod.serialize</code> and <code>qermod.deserialize</code> functions:</p> <pre><code>from qermod import serialize, deserialize, Bitflip\nnoise = Bitflip(error_definition=0.1)\nnoise_serial = deserialize(serialize(noise))\nassert noise == noise_serial\n</code></pre> <pre><code>\n</code></pre>"},{"location":"#specifying-target-gates-or-qubits","title":"Specifying target gates or qubits","text":"<p>To specify that a noise can only act on a type of gates, set of gates, or qubits, we need to specify the <code>target</code> attribute:</p> <pre><code>from qadence import X, Y\nnoise = Bitflip(error_definition=0.1, target=[X, Y(0)]) # any gate of type X or any Y applied on qubit 0\nnoise2 = Bitflip(error_definition=0.1, target=[0, 1]) # applied on qubit 0 and 1\n</code></pre> <pre><code>\n</code></pre>"},{"location":"#filtering","title":"Filtering","text":"<p>We can filter by noise type via the <code>filter</code> method:</p> <pre><code>from qermod import Noise\nfiltered_noise = digital_readout.filter(Noise.DIGITAL)\n</code></pre> <pre><code>[Bitflip(protocol=&lt;DigitalNoiseType.BITFLIP: 'BitFlip'&gt;, error_definition=0.100000000000000, target=[])]\n</code></pre>"}]}